# ASP.NET Docker Image / Self-contained Command Line Tool Docker Image

This type of project outputs a Docker image. Those images are pushed to a image repository.

## Prerequisites

* .NET solution file (i.e., `*.sln`), saved in the project root directory.
* .NET project (e.g., `*.csproj`), referenced by the .NET solution.
* `Dockerfile`, saved in the project root directory.

### Example ASP.NET `Dockerfile`

The following `Dockerfile` is compatible with this workflow recipe.

```Dockerfile
# https://hub.docker.com/_/microsoft-dotnet-aspnet/
FROM mcr.microsoft.com/dotnet/aspnet:latest AS image
WORKDIR /app
COPY build/app /app
ENTRYPOINT ["dotnet", "<ReplaceThisWithActualEntrypointAssembly>.dll"]
```

## High-level CI Workflow Compositions

The `validate` workflow needs to:

* Ensure the project(s) can `dotnet build`.
* Ensure the project(s) successfully pass `dotnet test`.

The `compose` workflow needs to:

* Compile the distributable executable using `dotnet publish`.
* Compile the Docker image (which may use the `dotnet publish` output).

The `publish` workflow needs to:

* Push the Docker image to the Docker repository.

## CI Environment

The following [`ciEnvironment` configuration][opinionated project structure] is expected with this recipe.

```json
{
  "ciEnvironment": {
    "variables": [
      {
        "name": "DOCKER_IMAGE_REPOSITORY",
        "description": "Docker image repository",
        "required": true,
        "secret": false,
        "defaultValue": null
      },
      {
        "name": "DOCKER_USERNAME",
        "description": "Docker username",
        "required": true,
        "secret": false,
        "defaultValue": null
      },
      {
        "name": "DOCKER_PASSWORD",
        "description": "Docker password or API token",
        "required": true,
        "secret": true,
        "defaultValue": null
      }
    ]
  }
}
```

## Bash CI Workflow Compositions

In this example, images are pushed to the _default_ server, as configured in the Docker daemon. I.e., Docker Hub, most commonly.

> Build output:
>
> * _Project root_`/build/`
>   * `app/` - Output of `dotnet publish`.
>   * `dist/`
>     * `nuget/` - NuGet package(s) generated by `dotnet pack`.
>   * `docs/` - Generated XML documentation.

### Using [Shell Library][shell library] Actions

> The CI [shell library][] assumes that the project is structured:
>
> * _Project root_`/` - Project root directory.
>   * `*.sln` - .NET solution file (e.g., `MyAwesomeProject.sln`).
>   * `src/` - Directory containing the primary .NET project (e.g., `.csproj`, `.fsproj`).

```bash
#--
# Validate the project's source, e.g. run tests, linting.
#--
ci-validate() {
  ci-dotnet-restore &&
    ci-dotnet-build &&
    ci-dotnet-test
}

#--
# Compose the project's artifacts, e.g., compiled binaries, Docker images.
#--
ci-compose() {
  ci-dotnet-publish &&
    ci-docker-build
}

#--
# Publish the project's artifact composition.
#--
ci-publish() {
  __conditionallyPushLatest() {
    if [[ "${RELEASE_ENVIRONMENT:-false}" = true ]]; then
      docker push "${DOCKER_IMAGE_REPOSITORY}:latest"
    fi
  }

  docker login --username "${DOCKER_USERNAME}" --password "${DOCKER_PASSWORD}" &&
    ci-docker-push &&
    __conditionallyPushLatest
}
```

### Using [Shell Library][shell library] Environment Variables

> This example is functionally equivalent to the "shell library actions" version above.
>
> This example uses a few [shell library][] actions (i.e., shell functions), e.g., `require-var`.

```bash
#--
# Validate the project's source, e.g. run tests, linting.
#--
ci-validate() {
  dotnet restore "${PROJECT_ROOT}" &&
    dotnet build "${PROJECT_ROOT}" \
    -p:GenerateDocumentationFile=true \
    -p:Version="${PROJECT_VERSION_DIST}" &&
    dotnet test "${PROJECT_ROOT}"
}

__tryApplyFallbackDockerEnvironment() {
  require-var "PROJECT_VERSION_DIST" "PROJECT_NAME"
  DOCKER_IMAGE_TAG="${DOCKER_IMAGE_TAG:-${PROJECT_VERSION_DIST}}"
  DOCKER_IMAGE_REPOSITORY="${DOCKER_IMAGE_REPOSITORY:-${PROJECT_NAME}}"
  DOCKER_IMAGE="${DOCKER_IMAGE_REPOSITORY}:${DOCKER_IMAGE_TAG}"
}

#--
# Compose the project's artifacts, e.g., compiled binaries, Docker images.
#--
ci-compose() {
  dotnet publish "${PROJECT_ROOT}/src" \
    --configuration Release \
    --output "${BUILD_UNPACKAGED_DIST}" \
    -p:DocumentationFile="${PROJECT_ROOT}/build/docs/${PROJECT_NAME}-${PROJECT_VERSION_DIST}.xml" \
    -p:Version="${PROJECT_VERSION_DIST}" &&
    __tryApplyFallbackDockerEnvironment &&
    require-var "DOCKER_IMAGE" &&
    docker build \
      --rm \
      --tag "${DOCKER_IMAGE}" \
      -f "${PROJECT_ROOT}/Dockerfile" \
      "${PROJECT_ROOT}"
}

#--
# Publish the project's artifact composition.
#--
ci-publish() {
  __conditionallyPushLatest() {
    if [[ "${RELEASE_ENVIRONMENT:-false}" = true ]]; then
      docker push "${DOCKER_IMAGE_REPOSITORY}:latest"
    fi
  }

  docker login --username "${DOCKER_USERNAME}" --password "${DOCKER_PASSWORD}" &&
    __tryApplyFallbackDockerEnvironment &&
    require-var "DOCKER_IMAGE" &&
    docker push "${DOCKER_IMAGE}" &&
    __conditionallyPushLatest
}
```

[opinionated project structure]: ../../use/project-structure.md
[shell library]: ../../use/ci-library.md
