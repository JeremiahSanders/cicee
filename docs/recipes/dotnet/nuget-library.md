# NuGet Library / .NET Tool

This type of project outputs NuGet packages. Both libraries and .NET tools are distributed in this manner.

## Prerequisites

* .NET solution file (i.e., `*.sln`), saved in the project root directory.
* .NET project (e.g., `*.csproj`), referenced by the .NET solution.
* Required environment variables:
  * `NUGET_API_KEY` - Nuget source API key (authentication).
  * `NUGET_SOURCE` - NuGet source.

## High-level CI Workflow Compositions

The `validate` workflow needs to:

* Ensure the project(s) can `dotnet build`.
* Ensure the project(s) successfully pass `dotnet test`.

The `compose` workflow needs to:

* Create the NuGet package.

The `publish` workflow needs to:

* Push the NuGet package to the remote NuGet source.

## CI Environment

The following [`ciEnvironment` configuration][opinionated project structure] is expected with this recipe.

```json
{
  "ciEnvironment": {
    "variables": [
      {
        "name": "NUGET_API_KEY",
        "description": "NuGet API Key",
        "required": true,
        "secret": true,
        "defaultValue": null
      },
      {
        "name": "NUGET_SOURCE",
        "description": "NuGet Source, e.g., 'nuget.org'",
        "required": true,
        "secret": false,
        "defaultValue": "nuget.org"
      }
    ]
  }
}
```

## Bash CI Workflow Compositions

> Build output:
>
> * _Project root_`/build/`
>   * `app/` - Output of `dotnet publish`.
>   * `dist/`
>     * `nuget/` - NuGet package(s) generated by `dotnet pack`.
>   * `docs/` - Generated XML documentation.

### Using [Shell Library][shell library] Actions

> The CI [shell library][] assumes that the project is structured:
>
> * _Project root_`/` - Project root directory.
>   * `*.sln` - .NET solution file (e.g., `MyAwesomeProject.sln`).
>   * `src/` - Directory containing the primary .NET project (e.g., `.csproj`, `.fsproj`).

```bash
#--
# Validate the project's source, e.g. run tests, linting.
#--
ci-validate() {
  ci-dotnet-restore &&
    ci-dotnet-build &&
    ci-dotnet-test
}

#--
# Compose the project's artifacts, e.g., compiled binaries, Docker images.
#--
ci-compose() {
  ci-dotnet-publish && ci-dotnet-pack
}

#--
# Publish the project's artifact composition.
#--
ci-publish() {
  ci-dotnet-nuget-push
}
```

### Using [Shell Library][shell library] Environment Variables

> This example is functionally equivalent to the "shell library actions" version above.

```bash
#--
# Validate the project's source, e.g. run tests, linting.
#--
ci-validate() {
  dotnet restore "${PROJECT_ROOT}" &&
    dotnet build "${PROJECT_ROOT}" \
    -p:GenerateDocumentationFile=true \
    -p:Version="${PROJECT_VERSION_DIST}" &&
    dotnet test "${PROJECT_ROOT}"
}

#--
# Compose the project's artifacts, e.g., compiled binaries, Docker images.
#--
ci-compose() {
  dotnet publish "${PROJECT_ROOT}/src" \
    --configuration Release \
    --output "${BUILD_UNPACKAGED_DIST}" \
    -p:DocumentationFile="${PROJECT_ROOT}/build/docs/${PROJECT_NAME}-${PROJECT_VERSION_DIST}.xml" \
    -p:Version="${PROJECT_VERSION_DIST}" &&
    dotnet pack "${PROJECT_ROOT}/src" \
    --configuration Release \
    --output "${BUILD_PACKAGED_DIST}/nuget/" \
    -p:DocumentationFile="${BUILD_DOCS}/${PROJECT_NAME}-${PROJECT_VERSION_DIST}.xml" \
    -p:PackageVersion="${PROJECT_VERSION_DIST}" \
    -p:Version="${PROJECT_VERSION_DIST}"
}

#--
# Publish the project's artifact composition.
#--
ci-publish() {
  for packageFile in "${BUILD_PACKAGED_DIST}"/nuget/*.nupkg; do
    dotnet nuget push "${packageFile}" --api-key "${NUGET_API_KEY}" --source "${NUGET_SOURCE}" &&
      printf "\n  Pushed '%s'" "${packageFile}"
  done
}
```

[opinionated project structure]: ../../use/project-structure.md
[shell library]: ../../use/ci-library.md
